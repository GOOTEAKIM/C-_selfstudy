# Panda coding C++ 입문

## section 1. Intro

### lec1_3

```C++
#include <iostream> // 전처리 지시자
```

- C++에서 그 함수를 사용하고자 한다면?
  - 반드시 함수의 원형을 미리 정의해야 한다.

```C++
using namespace std;
```

- std : 문자열 st
- ';' : 종결자, 줄을 바꿀 때 사용, 한 문장 끝날 때 사용해야한다.
- f5 : 출력


```C++
int main() {

	cout << "Hello, World" << endl;

	return 0;
}
```

- C++ 코드에는 반드시 main이란 함수가 있어야 한다.
- cout : print 느낌
- << : 데이터 흐름을 의미

## section 2. Dealing with Data

### lec2_1

- 변수 정할 때 규칙

  1. 숫자 불가
  2. c++ 에서 사용하는 키워드 불가
  3. white space 불가
---
### lec2_2

- short, int, long, long long

- 최댓값
  - short: 32767
  - int : 2147483647
  - long : 2147483647
  - longlong : 9223372036854775807

- 실수형 : 소수부가 있는 수
---
### lec2_3

- char : 작은 문자형
- null 문자 :  '\0'
- bool : 0 혹은 1만 나타내는 형태
---
### lec2_4

- 상수
  1. 바뀔 필요가 없는 수
  2. 바뀌면 안되는 수

- 데이터형 변환

1. 특정 데이터형의 변수에 다른 데이터형의 값을 대입했을 때
2. 수식에 데이터형을 혼합하여 사용했을 때
3. 함수에 매개변수를 전달할 때

- 강제적으로 데이터형 변환

  - typeName(a)
  - (typeName)a

  - static_cast<typeName>
---
### lec2_5

- 연산자 : +, -, *, /, %

- auto : 자동으로 변수형을 지정
---
## section 3. complex data

### lec3_1

- 배열 (array) : 같은 데이터형의 집합

```C++
// typeName arrayName[arraySize];
```
---
### lec3_2

- cin : 사용자가 입력한 것을 우측 변수에 저장해준다.
  - white space 는 무시한다. 
  - 공백이 있으면 끝났다고 생각한다.

- cin.getline : 공백 있는 것도 출력한다.

- sizeof : 길이를 출력
---
### lec3_3

- 구조체 : 다른 데이터형이 허용되는 데이터의 집합

- 배열 : 같은 데이터형의 집합
---
### lec3_4

- 공용체(union)
  - 서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있음

- 열거체 (enum)
  - 기호 상수를 만드는 것에 대한 또 다른 방법
---
### lec3_5

- C++ : 객체 지향 프로그래밍
  - 컴파일 시간이 아닌 실행 시간에 어떠한 결정을 내릴 수 있다.

- 배열을 만든다
  - 재래적 절차적 프로그래밍 : 배열 크기가 미리 결정되어야 한다.
  - 객체 지향 프로그래밍 : 배열의 크기가 실행 시간에 결정해도 된다.

- 포인터 : 사용할 주소에 이름을 붙인다.
  - 즉, 포인터는 포인터의 이름이 주소를 나타낸다.
  - 간접값 연산자, 간접 참조 연산자 '*'

```C++
int* b;
```
---
### lec3_6

- new 연산자

	- 어떤 데이터를 원하는지 new 연산자에게 알려준다.
	- new 연산자는 그에 알맞은 크기의 메모리 블록을 찾아낸다.
	- 그 블록의 주소를 리턴한다.

- delete 연산자

  - 사용한 메모리를 다시 메모리 폴로 환수
  - 환수된 메모리는 프로그램의 다른 부분이 다시 사용

	1. new로 대입하지 않은 메모리는 delete로 해제할 수 없다.
	2. 같은 메모리 블록을 연달아 두 번 delete 로 해제할 수 없다.
	3. new[] 로 메모리를 대입 할 경우 delete[]로 해제한다.
	4. 대괄호를 사용하지 않았다면 delete 도 사용하지 않는다.
---
### lec3_7

- strlen : 변수의 크기를 반환
- strcpy : 값을 복사?
---
## section 4. Loop

### lec4_1

- 반복문

  - for문
  - while문
  - do, while문

- for 문

  ```C++
  for (int i = 0; i < 5; i++) {
    cout << a[i] << endl;
  }
  ```

  1. 반복문에 사용할 카운터의 값을 초기화 (i)
  2. 반복문을 진행할 것인지 '조건 검사'
  3. 반복문 몸체를 수행한다. (={ } 안의 부분)
  4. 카운터의 값을 변화한다. (i++)
---

### lec4_2

- 전위 증가, 후위 증가

  - 후위 증가 (a++):
    - a의 원래 값을 먼저 사용한 후, 그 다음에 a가 증가합니다.
    - 즉, a++의 결과를 다른 변수에 할당하면, 증가되기 전의 값이 할당되고, 그 후에 a가 증가합니다.

    ```C++
    int a = 5;
    int b = a++;  // b에는 5가 들어가고, a는 6이 됩니다.
    ```

  - 전위 증가 (++a):
    - a가 먼저 증가한 후, 증가된 값이 사용됩니다.
    - 즉, ++a의 결과를 다른 변수에 할당하면, 증가된 값이 할당됩니다.

    ```C++
    int a = 5;
    int b = ++a;  // a는 6이 되고, b에도 6이 들어갑니다.
    ```

#### 요약

- a++ (후위 증가): 원래 값을 반환한 후에 증가.
- ++a (전위 증가): 먼저 증가한 후, 증가된 값을 반환.

---

### lec4_3

- while 문

  ```C++
    string animal = "Panda";

    int j = 0;

    while (animal[j] != '\0') {

      cout << animal[j] << endl;
      j++;
    }
  ```

- do, while문

  ```C++
    int f = 0;

    do {
      cout << "do, while 문입니다. \n";
      f++;
    } while (f < 3);

    return 0;
  ```

#### 주요 차이점

- while 문 
  - 조건을 먼저 평가하고, 조건이 참일 때만 반복을 시작합니다. 
  - 조건이 처음부터 거짓이면 실행되지 않습니다.
- do-while 문 
  - 한 번 실행 후 조건을 평가합니다. 
  - 따라서 최소 한 번은 블록이 실행됩니다.
---

### lec4_4

- 배열 기반 반복문

```C++

int arr[5] = { 1,3,5,7,9 };

for (int i = 0; i < 5; i++) {
  cout << arr[i] << endl;

}

// python
// for i in range(len(arr))

=>

// python
// for i in arr

for (int i : arr) {
  cout << i << endl;
}

```
---
